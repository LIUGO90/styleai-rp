# 调试总结：关于 localStorage 与 sessionStorage 的数据持久化问题

本文档旨在总结一次关键问题的调试过程。该问题导致了在从主生成页跳转到结果页时，用户的核心数据——尤其是原始衣物信息（`originalGarmentSrc`）——发生丢失。

## 基础概念：`localStorage` vs. `sessionStorage`

在深入问题之前，理解这两种浏览器存储方式的根本区别至关重要：

*   **`localStorage` (本地存储)**:
    *   **生命周期**: **持久化存储**。除非用户手动清除浏览器缓存或代码主动删除，否则数据会一直存在，即使用户关闭了浏览器或电脑。
    *   **作用域**: 在同一个源（域名、协议、端口）下，所有打开的标签页和窗口**共享**同一份 `localStorage` 数据。
    *   **用途**: 适合长期保存用户的个性化设置、登录状态、或像我们应用中的"历史穿搭记录"(`pastLooks`)。

*   **`sessionStorage` (会话存储)**:
    *   **生命周期**: **临时性存储**，与一个"会话"（Session）绑定。一个会话通常指一个浏览器标签页。当用户**关闭该标签页时，数据就会被自动清除**。
    *   **作用域**: 数据**仅在当前标签页内有效**，不同标签页之间的 `sessionStorage` 是隔离的，互不相通。
    *   **用途**: 适合临时传递一次性的、页面跳转间需要用到的数据，例如表单信息，或者我们最初尝试用来传递图片预览数据的场景。

## 核心问题

在结果页上使用"风格转换"（Transform with a New Style）功能时，程序因"找不到必要的图片源"而失败。经过调试发现，存储在 `localStorage` 中的 `pastLooks` 对象缺少了 `originalGarmentSrc` 这个关键字段。

## 排查与探索之旅

1.  **最初的假设 (HTTP 431 错误)**: 我们最先怀疑，当用户上传自定义图片时，其超长的 `base64` 数据被直接放入 URL，导致"HTTP 431 请求头字段过大"的错误。这个假设引导我们尝试了第一个解决方案。

2.  **方案一：使用 `sessionStorage`**
    *   **操作**: 我们修改逻辑，尝试通过 `sessionStorage` 来传递 `humanSrc` 和 `garmentSrc`，以避免 URL 过长。
    *   **新问题**: 这引发了一个更诡异的 Bug。日志显示，数据在主页(`/`)成功写入了 `sessionStorage`，但结果页(`/results`)加载时，读取到的却是 `null`。数据在页面跳转过程中"蒸发"了。

3.  **`sessionStorage` 的问题排查**: 我们怀疑干扰来自：
    *   **浏览器插件**: 像 "Screen Shader" 这样的插件被证实会干扰页面脚本的正常执行。
    *   **框架行为**: 在 Next.js 15 / React 19 这个较新的技术栈中，`sessionStorage` 在页面跳转间的行为极不稳定。其根本原因（组件生命周期竞争、框架特殊的处理机制等）尚不完全明确，但结果是其表现不可靠。

4.  **最终解决方案：回归 URL 参数**
    *   **顿悟**: 日志清晰地显示，在当前正常的工作流中（使用预设图片而非用户上传），图片路径是简短的字符串（如 `/cloth/blue-dress.png`），完全不足以导致 URL 过长。
    *   **操作**: 我们果断撤销了 `sessionStorage` 方案，恢复使用 URL search 参数来传递 `humanSrc` 和 `garmentSrc`。
    *   **结果**: 对于当前流程，这个方法被证明是 100% 可靠的。它彻底解决了数据丢失问题，使得结果页能够接收到 `originalGarmentSrc`，并将其正确地存入 `localStorage` 的 `pastLooks` 数组中。

## 关键总结与未来展望

*   **数据完整性的重要性**: "风格转换"功能对原始数据的依赖，警示我们在整个用户旅程中必须确保数据的完整性和一致性。
*   **`sessionStorage` 的不可靠性**: 在当前技术栈中，应谨慎使用 `sessionStorage` 来进行页面间的关键数据传递，它的行为可能出乎意料。
*   **一个潜在的隐患**: 最初由**用户上传 `base64` 图片**可能引发的 "HTTP 431" 问题，目前只是被**绕过**了，并未根治。如果支持用户上传自定义衣物是未来的核心功能，我们必须设计一个更健壮的方案。可能的方向包括：
    *   临时将 `base64` 数据存入更稳定的 `localStorage`。
    *   设计一个预上传步骤，将图片先发送到后端，后端将其临时存储在云端（如 S3）或缓存（如 Redis）中，仅将一个简短的图片 ID 传回前端进行后续操作。